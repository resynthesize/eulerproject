#!/usr/bin/perl
#
# Brandon Tallent (btallent@gmail.com)
#
# various attempts to solve http://projecteuler.net/problem=2
#
# Each new term in the Fibonacci sequence is generated by adding the previous
# two terms. By starting with 1 and 2, the first 10 terms will be:
# 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
# By considering the terms in the Fibonacci sequence whose values do not exceed
# four million, find the sum of the even-valued terms.
#
# timing
# .----------+---------+---------+----------.
# | Problem  | Attempt | Answer  | Time     |
# +----------+---------+---------+----------+
# | Problem2 | 1       | 4613732 | 0.000132 |
# | Problem2 | 2       | 4613732 | 6.6e-05  |
# | Problem2 | 3       | 4613732 | 3e-05    |
# | Problem2 | 4       | 4613732 | 0.000705 |
# | Problem2 | 5       | 4613732 | 0.000209 |
# '----------+---------+---------+----------'
#
# attempt 3 is the fastest, but I think attempt4 is the most elegant.

package Euler::Problem2;
use Method::Signatures::Simple;
use List::MoreUtils;
use Data::Dumper;
use Moose;

extends 'Euler';

has 'answer'             => ( is => "rw" );
has 'answers'            => ( is => "rw", lazy_build => 1 );
has 'fibonacci_sequence' => ( is => "rw", isa => 'ArrayRef', lazy_build => 1 );
has 'max'                => ( is => "ro", required => 1, default => 4_000_000 );
has 'phi'                => ( is => "ro", default => 1.61803398875 );
has 'sum'                => ( is => "rw" );

method _build_fibonacci_sequence ()
{
    my $a        = 1;
    my $b        = 1;
    my @sequence = ( $a, $b );
    my $c        = 0;

    while ( $c < $self->max )
    {
        $c = $a + $b;
        $a = $b;
        $b = $c;
        last if ( $c > $self->max );
        push @sequence, $c;
    }

    return \@sequence;
}

method _build_answers ()
{
    return $self->answer_attempts($self);
}

# first try
method attempt1 ()
{
    my $sum = 2;
    my @sequence = ( 1, 2 );
    while (1)
    {
        my $num = $sequence[-1] + $sequence[-2];
        last if $num >= $self->max;
        if ( $num % 2 == 0 )
        {
            $sum += $num;
        }
        push @sequence, $num;
    }
    $self->answer($sum);
}

# without using a list
method attempt2 ()
{
    my $a   = 1;
    my $b   = 1;
    my $c   = 0;
    my $sum = 0;
    while ( $c < $self->max )
    {
        if ( $b % 2 == 0 )
        {
            $sum += $b;
        }
        $c = $a + $b;
        $a = $b;
        $b = $c;
    }
    $self->answer($sum);
}

# avoid divisible by 2 check by just adding every
# third element
method attempt3 ()
{
    my $a   = 1;
    my $b   = 1;
    my $c   = $a + $b;
    my $sum = 0;
    while ( $c <= $self->max )
    {
        $sum += $c;
        $a = $b + $c;
        $b = $c + $a;
        $c = $a + $b;
    }
    $self->answer($sum);
}

# calculate next term by using the ratio between numbers in the sequence
# aka, the golden ratio or phi.
# (definitely did not come up with this one myself ;)
method attempt4 ()
{
    # first even term in the series.
    my $term = 2;
    my $sum  = $term;

    # the interval between any two terms of the series is ~phi.
    # since we want every 3rd term, raise phi to the third
    my $ratio = $self->phi**3;

    while ( $sum <= $self->max )
    {
        # we can now calculate the next term of the series by multiplying the
        # current term by our ratio, rounded to the nearest integer
        $term = int( ( $term * $ratio ) + 0.5 );
        $sum += $term;
    }

    $self->answer($sum);
}

# for fun, construct a list of all terms up to the max and add every third
# element.
method attempt5 ()
{
    my $sum;
    my @sequence = @{ $self->fibonacci_sequence };
    for ( my $i = 2 ; $i <= $#sequence ; $i += 3 )
    {
        $sum += $sequence[$i];
    }
    $self->answer($sum);
}

1;
